### 虾皮前端：

#### 1.进程和线程的区别，引出浏览器线程 （4）（1星）

​			1.根本区别：线程是cpu调度的最小单位，进程是资源分配的最小单位。

​			2.一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线。

​			3.进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见 

​			4.调度和切换：线程上下文切换比进程上下文切换要快得多。

#### 2.浏览器进程（4）：

###### 			2.1 浏览器多进程，浏览器多进程架构

​			浏览器的多进程包括：

​				1）主进程 Browser Process

​					负责浏览器界面的显示与交互。各个页面的管理,创建和销毁其他进程。网络的资源管理、下载等。

​				2）第三方插件进程 Plugin Process

​					每种类型的插件对应一个进程,仅当使用该插件时才创建。

​				3）GPU 进程 GPU Process

​					最多只有一个,用于 3D 绘制等

​				4）渲染进程 Renderer Process

​					称为浏览器渲染进程或浏览器内核,内部是多线程的。主要负责页面渲染,脚本执行,事件处理等。

###### 		2.2、浏览器进程一共分为5个线程，分别是GUI渲染线程，js引擎线程，事件触发线程，定时器触发线程，异步http请求线程。

​			1）GUI线程 ：

​					负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。

​					当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行

​					注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。

​			2）JS引擎线程：

​					也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）

​					JS引擎线程负责解析Javascript脚本，运行代码。

​					JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序

​					同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

​			3）事件触发线程：

​				归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）

​				当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中

​				当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理

​				注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）

​				js为什么是单线程，javaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

​			4）定时器触发线程：

​				传说中的setInterval与setTimeout所在线程

​				浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）

​				因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）

​				注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。

​			5）异步http请求线程

​				在XMLHttpRequest在连接后是通过浏览器新开一个线程请求

​				将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。

###### 2.3进程之间如何通信：

​		管道、信号量、共享内存、消息队列、socket。

####  3.js如何解决异步问题

1. 回调函数
2. 事件触发（on，bind，addEventListener，observe，listen)
3. 发布/订阅者模式
4. promise
6. async/await(ES7)

####  4.浏览器缓存，强缓存和协商缓存头部 （11）（3星）

​		浏览器缓存就是把一个已经请求过的web资源（如html页面，图片，JS，数据）拷贝一份放在浏览器中。缓存会根据进来的请求保存输入内容的副本。当下一个请求到来的时候，如果是相同的URL，浏览器会根据缓存机制决定是直接使用副本响应访问请求还是向源服务器再次发起请求。

​		4.1 强缓存：

​				1）Expires:

​						HTTP1.0中使用的强缓存关键字，是一个具体的时间，当客户端的时间小于Expires的值的时候，那么就会命中缓存

​				2）catch-control：

​						HTTP1.1中使用的强缓存关键字，主要有以下几个值：

​							public：所有内容都将被缓存（客户端和代理服务器都可缓存）

​							private：所有内容只有客户端可以缓存，Cache-Control的默认取值

​							no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定

​							no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存

​							max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效

​		4.3.协商缓存，etag实现原理（2）

​			协商缓存有两个关键字段：

​					1）last-modified/if-modified-since:

​							last-modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间。

​							if-modified-since是客户端再次发起请求时，携带上次请求返回的last-modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到请求之后，会根据if-modified-since的值和该资源在服务器的最后被修改时间做对比，根据情况返回200或者304.

​					2)Etag/if-none-match:

​							Etag是服务器响应请求时，返回当前资源文件的一个唯一标识（由服务器生成）。

​							if-none-match和if-modified的操作差不多。

#### 5.http状态码，304代表什么 （3）（2星）

1xx：已经收到信息，等待下一步的操作，用户不可见

2xx：请求成功，

3xx：重定向相关，需要进一步操作

​	301：永久重定向

​	302：临时重定向

​	304：未修改，和缓存相关

​	307：临时重定向，和302类似

4xx：请求错误，语义错误或者是无法完成请求

​	403：没有权限

​	404：没有请求到资源，网页不存在

5xx：服务器错误

​	500：服务器内部错误

​	503: 服务器超负荷

#### 6.css盒子模型

​	两种盒模型，w3c的标准盒模型以及ie的怪异盒模型

​	（1）主要就是两者的宽度计算不一样

​	（2）可以设定box-sizing: content-box和border-box

####   7.js基本数据类型，他们分别存储在哪儿 （3）

​		基本数据类型：字符串，数值，布尔值，null， undefined，ES6（symbol）

​		存储在栈中

​		引用数据类型：Object，Function， Array

​		他们的指针存放在栈中，具体内容存放在堆中。

​		7.2 引用数据类型和普通数据类型的区别： 

####  8.数组，链表，队列，栈，并且介绍他们的应用场景（3）（1星）

​		数组应用场景：

​		链表：LRU机制 ：双链表 + 哈希表

​		队列：消息队列，任务队列

​		栈：执行栈

####  9.前端安全和预防（6）

​		1、XSS（Cross Site Scripting）跨站脚本攻击

​			（1）原理：页面渲染的数据中包含可运行的脚本

​			（2）攻击的基本类型：**反射型**（url参数直接注入）和**存储型**（存储到DB后读取时注入）

​			（3）注入点：HTML节点内的内容（text）；HTML中DOM元素的属性；Javascript代码；富文本

​		2、CSRF（Cross Site Request Forgy）跨站请求伪造

​				原理：在第三方网站向本网站发起请求

​			（1）用户在a站前端页面发起登录（身份认证）请求

​			（2）a站后端确认身份，登录成功，cookie中存在用户的身份认证信息

​			（3）b站前端页面向a站后端发起请求，带着a站的cookie信息（身份认证信息），请求成功

​		3、点击劫持

​				原理：第三方网站通过iframe内嵌某一个网站，并且将iframe设置为透明不可见，将其覆盖在其他经过伪装的DOM上，伪装的可点击DOM（按钮等）与实际内嵌网站的可点击DOM位置相同，当用户点击伪装的DOM时，实际上点击的是iframe中内嵌的网页的DOM从而触发请求操作

-  CSRF是什么 （跨站请求伪造）
-  CSRF在另外的网站发起攻击还是访问的网站？（另外的网站）
-  怎么防御？ （验证码，token，谷歌浏览器的samesite）
-  token存在哪（localstorage，session）
-  samesite的lax

####  10.let const var （5）

​		1)let和const都拥有块级作用域，var没有

​		2）var声明的变量可以重复声明，但是let和const不可以

​		3）const用来声明常量，对于基本数据类型来说，一旦声明就不可以修改值。

​		4）在非严格模式下，var的变量可以在声明之前使用。let和const不行。

​		5）var的值会与window相映射，但是let和const不会

####  11.TCP和UDP区别 （2）

​		1）TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接

​		2）TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保  证可靠交付

​		3）TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的
 UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）

​		4）每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信

​		5）TCP首部开销20字节;UDP的首部开销小，只有8个字节

​		6）TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

####  12.set,map ,weakSet,weakMap （2）

​		set:集合形式，内部元素不可以重复

​		map：键值对形式，key不能重复，但是value可以重复

​		1）WeakSet的成员只能是对象，WeakMap只接受对象（null除外）作为键名

​		2）不计入垃圾回收机制:

​				WeakSet中的对象不计入垃圾回收机制，WeakMap中键名指向的对象不计入垃圾回收机制

​		3）WeakSet和WeakMap没有遍历操作，没有size属性，没有clear方法

####   13.web worker 

​		Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。

​		Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。

#### 14.什么是稳定的排序算法，稳定排序算法有哪些（5）（常考快排，归并，稳定性，堆排考了一次）

![img](https://img-blog.csdn.net/20180807211041585?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhbnhpYW9yYW45MDY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

#### 15.事件循环（7）：

​		同步和异步任务分别进入不同的执行环境，同步的进入主线程，即主执行栈，异步的进入任务队列。主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。 上述过程的不断重复就是我们说的 Event Loop (事件循环)。

#### 16.回流和重绘（4）：

什么是回流

​			当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。

什么是重绘

​			当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。

​		区别：

​			他们的区别很大：
 			回流必将引起重绘，而重绘不一定会引起回流。比如：只有颜色改变的时候就只会发生重绘而不会引起回流
 			当页面布局和几何属性改变时就需要回流
 			比如：添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变

###### 			16.2 reflow、减少机制，措施

#### 17.script标签的async和defer的区别（5）：

​		asyn和defer，这两个属性使得script都不会阻塞DOM的渲染。

​		区别：

​		1）如果script标签设置了该属性，则浏览器会异步的下载该文件并且不会影响到后续DOM的渲染；如果有多个设置了defer的script标签存在，则会按照顺序执行所有的script，defer脚本会在文档渲染完毕后，DOMContentLoaded事件调用前执行。

​		2）async的设置，会使得script脚本异步的加载并在允许的情况下执行async的执行，并不会按着script在页面中的顺序来执行，而是谁先加载完谁执行。

#### 18.判断数组的四种方法：

​	1）instanceof运算符：

​		这个运算符可以判断一个对象是否是在其原型链上原型构造函数中的属性。

```js
let arr = [];
console.log(arr instanceof Array); //true
```

​	2）constructor：

​		这个属性是返回对象相对应的构造函数。

```js
let arr = [];
console.log(arr.constructor == Array); //true
```

​	3）写一个函数方法：

```js
let arr = [];
var isType = function (obj) {
     return Object.prototype.toString.call(obj).slice(8,-1);
}
console.log(isType(arr) == 'Array'); //true
```

​	4）数组自带的isArray方法：

```js
let arr = [];
console.log(Array.isArray(arr)); //true
```

#### 19.水平垂直居中方法（3）：

​	1）绝对定位：父级设置为relative，子级设置为absolute，利用top，left和margin-top以及margin-left来控制

​	2）利用margin：auto：子级设置为margin：auto，注意absolute下margin：auto失效，所以要设置top，left，right和bottom 为0；

​	3）display：table-cell ：父级元素设置为display：table-cell，vertical-align:middle,text-align:center;注意子元素要设置为display：inline-block

​	4）display：flex: 父元素设置为display：flex，同时设置justify-content:center;align-items:center;

​	5）利用transform： 子元素设置绝对定位，top和left：50%，同时设置transform：translate（-50%，-50%）

​	6）利用grid布局： 父元素：display：grid，align-items:center,注意子元素要设置为：margin：auto。

#### 20.vdom的原理（2）：

​		虚拟DOM用javascript对象来表示VNode，VNode的结构如下

#### 21.vue-router原理（3）：

​		路由原理，hash模式和history模式用什么实现

​		1）hash模式通过onhashchange事件进行实时监听url中hash值的变化，由此来根据hash值的变化进行一些dom的切换操作。

​		2）history模式主要用到 了history对象里的history.pushState()和history.replaceState()这两个接口。两个方法均接受三个参数分别是state（history实体的相关信息，json），title（标题）和url（相对路径，值为null代表没有改变）；



#### 22.跨域方法、同源策略（8）：

​		1）同源策略：

​				同源值得是协议，域名和端口相同。同源策略是一种安全协议，指的是浏览器对不同源的脚本或者文本的访问方式进行的限制。

​		2）什么是跨域：

​				指的是浏览器不能执行其他网站的脚本，它是由浏览器的同源策略造成的，是浏览器对javaScript施加的安全限制，防止他人恶意攻击网站。

​		3）解决跨域的方法：

​				a. jsonp

​						原理：动态创建一个script标签，利用script标签的src属性不受同源策略限制（herf属性也不受限制）。

​						特点：

​						步骤：

​								动态创建一个script： document.createElement("script")；

​								script的src属性设置接口地址

​								接口参数，必须要带一个自定义的函数名，要不然后台无法返回数据。

​								通过定义函数名去接收后台返回数据

​				b.CORS:  跨域资源共享

​						原理：服务器设置Access-Control-Allow-Origin Http响应头之后，浏览器将会允许跨域请求

​						缺点：

​						

​				c.nignx反向代理：

​						原理：

​				d.webSorkets

​						web sockets： 是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用)

​						web sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。

```
<script>
var socket = new WebSockt('ws://www.test.com');
//http->ws; https->wss
socket.send('hello WebSockt');
socket.onmessage = function(event){
    var data = event.data;
}
```

​		5） 同源策略，CORS，多个复杂请求怎么优化（OPTION请求首部有时间相关的首部） 

​		6）cookie跨域携带（cores）

​				客户端：xhr.withCredentials = true;

​				服务端：Access-Control-Allow-Credentials: true

#### 23.js六种继承方式以及缺点，super用法（4） ：

​	js继承：通过**某种方式**让一个对象可以访问到另一个对象中的属性和方法，我们把这种方式称之为继承 

​	父类：

```js
function Person(name) {
	this.name = name;
    this.sum = function() {
        console.log(this.name);
    }
}
Person.prototype.age = 10;
```

​	1)原型链继承：

```js
function Per() {
    this.name = "test";
}
Per.prototype = new Person();
let p = new Per();
console.log(p.name, p.age, p.sum)
```

重点：让新实例的原型等于父类的实例。

特点：1、实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的属性！）

缺点：1、新实例无法向父类构造函数传参。
　　　2、继承单一。
　　　3、所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改!）

​	2）构造函数继承：

```js
function child() {
	Person.call(this, "jer");
    this.age = 15;
}
let c1 = new child();
console.log(c1.name, c1.age, c1.sum);
```

重点：用.call()和.apply()将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制））

特点：1、只继承了父类构造函数的属性，没有继承父类原型的属性。
　　　2、解决了原型链继承缺点1、2、3。
　　	3、可以继承多个构造函数属性（call多个）。
　　　4、在子实例中可向父实例传参。

缺点：1、只能继承父类构造函数的属性。
　　　2、无法实现构造函数的复用。（每次用每次都要重新调用）
　　　3、每个新实例都有父类构造函数的副本，臃肿。

​	3）组合继承（组合原型链继承和借用构造函数继承）（常用）

```js
function child2(name) {
    Person.call(this, name);
}

child2.prototype = new Person("per");
let c2 = new child2("net");
console.log(c2.name, c2.age, c2.sum)
```

重点：结合了两种模式的优点，传参和复用

特点：1、可以继承父类原型上的属性，可以传参，可复用。
　　　2、每个新实例引入的构造函数属性是私有的。

缺点：调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。

​	4）原型式继承：

```js
function content(obj) {
    //封装一个函数，内部用一个空函数使用原型链继承来继承父类的属性和方法，最后把实例返回
    function F() {}
    F.prototype = obj; //继承了传入的参数
    return new F();
}
var sub = new Person("net");
var sub1 = content(sub);
console.log(sub1.name, sub1.age, sub1.sum);
```

重点：用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。object.create()就是这个原理。

特点：类似于复制一个对象，用函数来包装。

缺点：1、所有实例都会继承原型上的属性。
　　　2、无法实现复用。（新实例属性都是后面添加的）

​	5）寄生式继承：

```js
function content(obj) {
    function F(){}
    F.prototype = obj;
    return new F();
}
var sup = new Person();
function subobject(obj) {
    var sub = content(obj);
    sub.name = "gar"
    return sub;
}
var sup2 = subobject(sup);
console.log(sup2.name, sup2.age, sup2.sum)
```

重点：就是给原型式继承外面套了个壳子。

优点：没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。

缺点：没用到原型，无法复用。

​	6）寄生组合式继承（常用）

寄生：在函数内返回对象然后调用
组合：1、函数的原型等于另一个实例。2、在函数中用apply或者call引入另一个构造函数，可传参

```js
function content(obj) {
    function F(){}
    F.prototype = obj;
    return new F();
}
var con = content(Person.prototype);

function Sub() {
    Person.call(this, 'sully');
}

Sub.prototype = con;
con.constructor = Sub;
var sub1 = new Sub();
console.log(sub1.name, sub1.age, sub1.sum)
```

重点：修复了组合继承的问题

#### 24.深浅拷贝及区别 (2）：

#### 25.https 、https的加密（5）http和https ：

 		你知道https吗？讲一下他的流程？

​		http与https的区别 		https非对称加密过程 

#### 26.jwt

#### 27.vue的组件化会如何实现（具体怎么问不确定，大概这么个意思），聊到了思路，怎么实现，结构，[算法]()，编译过程等 

#### 28.vuex看法，怎么用

#### 29.手写栈，复杂度有要求 

#### 30.Vue 双向绑定 （4），原理，具体实现

#### 31.get和post的区别（2）post用什么来传输数据 

#### 32.浏览器输入URL到页面显示涉及到缓存的部分

#### 33.垃圾回收机制 

#### 34.js for in for of区别：

#### 36.判断数组的四种方法：

#### 37.闭包相关：写一个内存函数，第一次进行计算，以后每次调用函数都返回这个计算结果，利用闭包 （5）

#### 38.什么是图片懒加载、怎么实现图片懒加载

#### 39.描述一下防抖与节流、实现一个防抖或节流（3）

#### 40.简单说一下vue

#### 41.渲染是在宏任务完成之后还是微任务完成之后

#### 42.事件循环机制线程是独立吗

#### 43.定时器的计时是由谁决定的（哪个线程）

#### 44.原型链

#### 45.**proto**与prototype的区别

#### 46.原型链添加函数实现字符串翻转

#### 47.匿名函数与包含它的函数的关系

#### 48.函数的返回问题

#### 49.高阶函数

####  50.缓存存储位置，Cache文件夹 

####  51.cookie 

####  52.同源网站和同站点网站的cookie设置 

####  54.内存泄漏，导致的原因，减少方法 

#### 59.es6 新语法 

#### 61.弱引用的具体场景 

#### 62.箭头函数 （3）（略）

#### 63.css 0.5 px实现 

​	使用缩放实现（transform：scale）

#### 65.三栏布局 

#### 66.postiton各属性 、absolute定位是想对于那个开始的（2）（略）

#### 67.样式优先级 （略）

!important > 行内样式 > id选择器 > 类选择器 伪类选择器> 标签选择器 伪元素> 通用选择器

#### 68.bfc 

BFC 

-  怎么生成BFC？ 
-  BFC怎么解决上下元素的margin的重叠问题(说错了) 

#### 69.flex （略）

-  flex:1? 
-  flex :1不简写是什么(说的1 1 0%) 
-  flex: auto表示什么

#### 70.es6 module循环引用题 

#### 71.问了ajax的使用步骤，status为啥。好像还涉及事件捕获处理冒泡那个流程。然后又问了事件代理。 

#### 74.两栏布局（多种） （3）

 flex设为1为什么可以实现两栏（flex属性的内容）

#### 76.promise怎么捕获错误，为什么try/catch不可以捕获异常错误 

 多个promise错误怎么捕获 

#### 77.html5中的preload

#### 78.vue更新数据是同步还是异步

​		数据是同步更新，视图是异步更新

#### 79.一个变量改变多次renden会调用几次 

​		一次

81.vue怎么监听对象属性的增加或删除 

-  vue3怎么做的 
-  vue2里面可以怎么做（不会，面试完想到难道是vm.$set()？）

82.列表懒加载，多次加载数据后卡顿的原因，如何优化 

83.http结构啥的

84.七层结构

88.伪类和伪元素有什么区别 



 说输出 

[复制代码](#)

```js
var a, b
(function() {
    alert(a);
    alert(b);
    var a = (b = 3);
    alert(a);
    alert(b); 
})()
alert(a);
alert(b);// undefined undefined 3 3 undefined 3
```

[复制代码](#)

```js
  <div id="out">
      <div id="in"></div>
</div>
document.getElementById("out").addEventListener("click",function() {console.log("key1");}, true) document.getElementById("in").addEventListener("click", function() {console.log("key2");   }, true) document.getElementById("out").addEventListener("click", function(){console.log("key3");}, false) document.getElementById("in").addEventListener("click", function(){console.log("key4");}, false)//"key1" "key2" "key4" "key3"
```

[复制代码](#)

```js
1.var a = 10 
2.var obj = {
3.   a: 20,
4.   say: () => {
5.    console.log(this.a)
6.   }
7.}
8.obj.say()
9.var anotherObj={a:30}
10.obj.say.apply(anotherObj)// 10 10
```

[复制代码](#)

```js
var a = 10
var obj = { 
    a: 20,
    say(){
        console.log(this.a)
    }
}
obj.say()
var anotherObj={a:30}
obj.say.apply(anotherObj)//20 30 
```

[复制代码](#)

```js
let a = {}, b = Object.prototype;
console.log(a.__proto__ === b);//true
console.log(Object.getPrototypeOf(a) === b);//true
```

[复制代码](#)

```js
function f() {}
f.__proto__ === ?;//Function.prototype
```

#### 78.cookie、localstorage、sesstionstorage的区别

#### 79.webpack热更新原理 

#### 80.plugin、loader区别 

#### 81.你知道commonjs和es6模块的区别吗？

#### 82.二叉树的层序遍历；自己构建一颗二叉树验证你的代码。 

#### 83.手撕题：一道class链式调用 

#### 84.输入url到页面展示的过程 

​		1）输入地址

​		2）浏览器查找域名的ip地址

​				浏览器会首先查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。

​				如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS请求到本地DNS服务器 。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。

​				查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询。

​				根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。这种过程是迭代的过程。

​				本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。

​				最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。

​		3）浏览器向 web 服务器发送一个 HTTP 请求

​				通过三次握手机制，建立TCP/Ip的连接

​		4）服务器的永久重定向响应

​				是为了加上www

​		5）浏览器跟踪重定向地址

​		6）服务器处理请求

​		7）服务器返回一个 HTTP 响应

​		8）浏览器显示 HTML

​		9）浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）

#### 85.vue、react的区别

#### 86.10000个子节点，插入到页面，怎么插入 

#### 87.css absloute 相对什么定位 如果不设置position的话 默认值是啥 

#### 88.get、post区别，一个get请求能用post方法去请求么 

#### 89、h5新特性 
